# 1. grid_cost_map
## 坐标系
目前出现了如下几种关于地图的数据格式，其坐标系定义如下：
- GridMap: 栅格地图，以栅格坐标系表示，比较特殊，原点在正中央，见官方手册吧。
- cv::Mat: opencv的坐标系。左上角为原点，x轴(col)向右，y轴(row)向下。
- nav_msgs::OccupancyGrid: ROS的坐标系。左下角为原点，x轴(width)向右，y轴(height)向上，z轴符合右手坐标系。ori_x和ori_y表示地图原点（左下角）在坐标系中的位置，是一个偏移量。

在使用过程中，有如下坐标系转换的过程：
- 在线使用过程：
  - map_loader加载pcd以点云形式发布。
  - 上述点云被grid_cost_map转换成nav_msgs::OccupancyGrid，发布到ROS。其中将建图时原点与/map原点重合（通过ori_x和ori_y实现）。
  - 此外，将nav_msgs::OccupancyGrid（手动！！！）转换成cv::Mat保存到本地。这个过程中，乍一看会产生上下方向的颠倒，实际上不需要手动翻转，因为cv::Mat仅作为存储媒介，后续加载cv::Mat并转换成nav_msgs::OccupancyGrid时，也不翻转，这样刚好不会产生影响。
  - 后续GlobalPlanning接收到nav_msgs::OccupancyGrid，再次转换成cv::Mat，并进行路径规划。同样，规划时cv::Mat仅是媒介，不需要翻转。
- 离线使用过程：
  - grid_cost_map加载已经存储好的png，转换成nav_msgs::OccupancyGrid，发布到ROS。此时不考虑建图原点与/map原点的重合了，ori_x和ori_y都为0，即整个OccupancyGrid的左下角为原点。
  - 后续GlobalPlanning接收到nav_msgs::OccupancyGrid，再次转换成cv::Mat，并进行路径规划。同样，规划时cv::Mat仅是媒介，不需要翻转。
- GlobalPlanning中的特殊使用：
  - 在GlobalPlanning的test_ros.cpp中，跳过了grid_cost_map节点，直接在该节点中加载了png作为cv::Mat，并直接传入planner中。

转换过程细则：
- cv::Mat <-> nav_msgs::OccupancyGrid: 手动转换，只储存数据，坐标系翻转翻转与否完全不影响，只需要记住按顺序读取即可。
- GridMap <-> nav_msgs::OccupancyGrid: 调库实现，从GridMap转换到nav_msgs::OccupancyGrid时，底层库将nav_msgs::OccupancyGrid的ori_x和ori_y设置为```Position position = gridMap.getPosition() - 0.5 * gridMap.getLength().matrix();```，而```gridMap.getPosition()```设置为建图原点坐标系（也即点云坐标系）下(min+max)/2，上式化简后ori_x=min_x，ori_y=min_y。因此，nav_msgs::OccupancyGrid原点（即/map原点）就是slam建图时起点。

实例：
- XG_map中，明显可以看到/map坐标系原点就是在建图起点
- carla_map中，是我自己用RoadRunner创建的地图，创建的时候是严格以0为原点的，因此最终/map坐标系原点就是在正中央，这是合理的。

## 数据格式
- cv::Mat: ```map.at<uchar>(row, col)```，是按照opencv中行列表示的。
- nav_msgs::OccupancyGrid: ```grid.data[index]```，是用一位数组表示二维grid的。按照nav_msgs::OccupancyGrid的坐标系，先存储一列，再存储下一列，以此类推，最后一行也存储完毕。

通常cv::Mat和nav_msgs::OccupancyGrid都可以互相转换，但比较特殊，转换时大致如下：
```cpp
  int rows = occupancy_grid_map.info.height;
  int cols = occupancy_grid_map.info.width;
  cv::Mat map = cv::Mat::zeros(rows, cols, CV_8UC1);
  for (size_t i = 0; i < rows; i++)
  {
      for (size_t j = 0; j < cols; j++)
      {
          map.at<uchar>(i, j) = occupancy_grid_map.data[i * cols + j];
      }
  }
```

## 数值含义
- GridMap: 原始数据形式，包含多层，最终只用'traversability'层，值为[0.0, 1.0]以及NaN。后续只将该层转换成其他数据类型。
- nav_msgs::OccupancyGrid: 发布到ROS的地图数据，值为[0, 100]整型，由GridMap转换而来，且一一映射，NaN特殊处理为255。在rviz中，[0, 100]表示不同深浅的白->黑，255为墨绿色。
- cv::Mat: 保存到本地的地图数据，值为[0, 255]整型，由nav_msgs::OccupancyGrid转换而来，完全的数值复制，没有其他处理。通常在cv领域，0表示黑色，255表示白色。刚好与上述rviz相反。

# 2. global_planning
## 坐标系
- 全部都在ros的 `/map`坐标系下。
- 由于存在栅格地图，包括代价地图，距离地图等，都是通过离散的栅格存储值，因此就必定涉及到分辨率res。
- 在global_planning中，只有输入和输出的路径点是转换到真实值的，其余所有中间计算过程点都归一化成栅格值（整数、小数都包括）。这一点和local_planning不同


# 3. local_planning
## 坐标系
- 包含`/map`和`/veh`两个坐标系
- 与global_planning类似，也有栅格地图，也有res。不同点是：local_planning所有计算都在原始值环境中进行，仅与栅格地图有关时再归一化（这点与global_planning不同！！！）。


# 4. 碰撞检测
- 与地形层的多层代价地图检测碰撞使用三碰撞圆检测。global_planning与local_planning都有体现。
- 与其他物体（车辆，行人等实体）的碰撞检测使用OBB包围盒检测。local_planning中使用。

# 5. control
自己实现的简单的控制算法，横纵都为PID控制。目前为50Hz。在此包中，线速度v可以为负数。

# 6. simulation
自己通过代码模拟仿真环境，引入了噪声，目前为100Hz。在此包中，线速度v可以为负数。

# 7. carla仿真环境
## 我的carla仿真环境
我是在宿主机windows上启动carla服务器的，虚拟机ubuntu上启动carla客户端。  
- windows与ubuntu通信是通过`VMware Network Adapter VMnet8`。  
- windows ip: `192.168.86.1`
- ubuntu ip: `192.168.86.4`， 使用桥接模式  
- 地图使用自己从RoadRunner中制作的地图。
  - 自制地图名字：`MyScene`
  - 自制地图路径：`D:\carla-0.9.15\Unreal\CarlaUE4\Content\package\Maps\MyScene`
  - 修改carla地图的配置文件位于：`D:\carla-0.9.15\Unreal\CarlaUE4\Config\DefaultEngine.ini`
  - 配置文件中修改四处，修改后为：`/Game/package/Maps/MyScene/MyScene.Myscene`

## 启动carla服务器
- windows启动carla服务器步骤，必须使用`x64 Native Tools Command Prompt for VS 2022`终端，已经固定在了开始菜单中。  
- 使用如下命令启动carla服务器（都已我的电脑目前路径为例）：
    ```bat
        cd /d D:
        cd carla-0.9.15
        make launch-only
    ```
- 等待后启动ue4的carla界面。点击运行即可启动服务端。
- 服务端ip就是windows的ip，即`192.168.86.1`，端口是`12345`，可以修改。

## 启动carla客户端demo
- windows/ubuntu均可，使用vscode的终端，切换至已经创建好的虚拟环境`carla`
- 如果在ubuntu启动客户端，记得关闭windows的防火墙！！
- 在`carla-0.9.15`文件夹下，
  - windows不需要再次指明服务器ip和端口，直接使用如下命令启动carla客户端：
    ```bat
        cd PythonAPI/examples
        python manual_control.py
    ```
  - ubuntu需要指明服务器ip和端口，使用如下命令启动carla客户端：
    ```bash
        cd PythonAPI/examples
        python manual_control.py --host=192.168.86.1 --port=12345
    ```
- 成功后即可看到pygame界面的carla客户端。通过键盘控制汽车的行驶。


# 报错
- tf2_ros报错，由于python2 和 python3引起

>下面方法仅供参考。实际上carla-ros-bridge中已经包含了python3编译过的tf，也就是正常情况下可以直接使用bridge不会报错。而下面的报错原因是使用source了别的工作空间，覆盖了bridge空间的变量导致的。因此理论上这个报错不解决也可以。  
>另外，目前考虑不使用carla了，用别的方法替代了。

```
  File "/home/brucesun/carla-ros-bridge/catkin_ws/src/carla_ros_bridge/src/carla_ros_bridge/sensor.py", line 27, in <module>
    import tf2_ros
  File "/opt/ros/melodic/lib/python2.7/dist-packages/tf2_ros/__init__.py", line 38, in <module>
    from tf2_py import *
  File "/opt/ros/melodic/lib/python2.7/dist-packages/tf2_py/__init__.py", line 38, in <module>
    from ._tf2 import *
ImportError: dynamic module does not define module export function (PyInit__tf2)
```
解决方法是从官网下载源码后重新使用python3编译tf2。并需要在python3使用tf2时，source新编译的tf工作空间  
参考：https://blog.csdn.net/clashes/article/details/134784496
```bash
mkdir -p tf/src
cd tf/src
git clone https://github.com/ros/geometry2
catkin_make --cmake-args \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_PREFIX_PATH=/opt/ros/melodic \
            -DPYTHON_EXECUTABLE=/usr/bin/python3 \
            -DPYTHON_INCLUDE_DIR=/usr/include/python3.6m \
            -DPYTHON_LIBRARY=/usr/lib/x86_64-linux-gnu/libpython3.6m.so
```
每次使用python3调用tf2前，都需要source编译后的工作空间.也可以直接将该指令写入bashrc文件，每次开机自动source：
```bash
source ~/tf/devel/setup.bash
```
> 注：不source该tf工作空间，python2可以正常调用tf2；source后，只能用python3调用tf2。

完成上面内容后，就可以在python3中import tf了。但是会遇到的新的问题：ros只能source一个工作空间，source多个工作空间会被覆盖，因此source完tf工作空间后，本工作空间将无法使用。考虑到tf工作空间编译的特殊性，且不需要修改/多次编译，因此也不合适将tf工作空间合并到本工作空间。  
目前采用的解决方法是：借鉴carla-ros-bridge，将tf的路径也一块硬编码到carla-ros-bridge中，这样只需要开机默认source carla-ros-bridge工作空间即可。这样做也兼顾了：只有使用carla-ros-bridge时才需要通过python3调用tf，其他时候不需要。  
具体做法：找到`/home/brucesun/carla-ros-bridge/catkin_ws/devel/_setup_util.py`，修改line 271，从
```python
CMAKE_PREFIX_PATH = r'/home/brucesun/carla-ros-bridge/catkin_ws/devel;/opt/ros/melodic'.split(';')
```
改为
```python
CMAKE_PREFIX_PATH = r'/home/brucesun/tf/devel;/home/brucesun/carla-ros-bridge/catkin_ws/devel;/opt/ros/melodic'.split(';')
```
而carla-ros-bridge工作空间已经通过.bashrc自动source，且carla-ros-bridge不需要再次编译等，不会被覆盖。
可以通过如下命令验证当前识别的工作空间：
```bash
echo $ROS_PACKAGE_PATH
```